<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ZenKit 3D Viewer (OpenGothic Pipeline)</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 0;
            background: #000;
            color: white;
            overflow: hidden;
        }

        .container {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
        }

        .viewer-container {
            flex: 1;
            position: relative;
            background: #111;
        }

        #threejs-canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        .render-info {
            display: none;
        }
    </style>
</head>
<body>
    <div class="container">

        <div class="viewer-container">
            <canvas id="threejs-canvas"></canvas>
            

            <div class="render-info" id="renderInfo">
                <div>FPS: <span id="fps">0</span></div>
                <div>Triangles: <span id="triangles">0</span></div>
                <div>Draw Calls: <span id="drawCalls">0</span></div>
            </div>
        </div>
    </div>

    <script type="module">
        // Import Three.js from CDN
        import * as THREE from 'https://cdnjs.cloudflare.com/ajax/libs/three.js/0.180.0/three.module.min.js';
        
        let ZenKit = null;
        let scene, camera, renderer;
        let worldMesh = null;
        let stats = { triangles: 0 };

        // Initialize Three.js Scene
        function initThreeJS() {
            const canvas = document.getElementById('threejs-canvas');
            
            // Scene - match reference viewer
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x222222);
            
            // Camera with optimized near/far planes to reduce z-fighting
            camera = new THREE.PerspectiveCamera(75, canvas.clientWidth / canvas.clientHeight, 1.0, 100000);
            camera.position.set(0, 1000, 2000);
            
            // Renderer with enhanced depth buffer settings - match reference viewer
            renderer = new THREE.WebGLRenderer({ 
                canvas, 
                antialias: true,
                logarithmicDepthBuffer: true  // Better depth precision for large scenes
            });
            renderer.setSize(canvas.clientWidth, canvas.clientHeight);
            renderer.outputColorSpace = THREE.SRGBColorSpace; // Critical for proper color display
            
            // Additional depth buffer settings for better rendering
            renderer.sortObjects = true;  // Ensure proper depth sorting
            renderer.autoClear = true;
            
            // Note: MeshBasicMaterial doesn't use lighting, so lights won't affect appearance
            
            // Simple orbit controls (manual implementation)
            setupControls();
            
            // Handle resize
            window.addEventListener('resize', onWindowResize);
        }
        
        function setupControls() {
            let isMouseDown = false;
            let mouseX = 0, mouseY = 0;
            let targetX = 0, targetY = 0;
            let distance = 3000;
            
            const canvas = renderer.domElement;
            
            canvas.addEventListener('mousedown', (event) => {
                isMouseDown = true;
                mouseX = event.clientX;
                mouseY = event.clientY;
            });
            
            canvas.addEventListener('mousemove', (event) => {
                if (!isMouseDown) return;
                
                const deltaX = event.clientX - mouseX;
                const deltaY = event.clientY - mouseY;
                
                targetX += deltaX * 0.01;
                targetY += deltaY * 0.01;
                targetY = Math.max(-Math.PI/2, Math.min(Math.PI/2, targetY));
                
                mouseX = event.clientX;
                mouseY = event.clientY;
                
                updateCameraPosition();
            });
            
            canvas.addEventListener('mouseup', () => {
                isMouseDown = false;
            });
            
            canvas.addEventListener('wheel', (event) => {
                distance += event.deltaY * 2;
                distance = Math.max(100, Math.min(50000, distance));
                updateCameraPosition();
                event.preventDefault();
            });
            
            function updateCameraPosition() {
                camera.position.x = Math.cos(targetX) * Math.cos(targetY) * distance;
                camera.position.y = Math.sin(targetY) * distance;
                camera.position.z = Math.sin(targetX) * Math.cos(targetY) * distance;
                camera.lookAt(0, 0, 0);
                renderer.render(scene, camera);
            }
            
        }

        async function initZenKit() {
            try {
                const ZenKitModule = (await import('../build-wasm/wasm/zenkit.mjs')).default;
                ZenKit = await ZenKitModule();
                updateStatus(`‚úÖ ZenKit ${ZenKit.getZenKitVersion()} initialized successfully!`, 'success');
                
                // Initialize Three.js
                initThreeJS();
                
                // Try to load TOTENINSEL.ZEN automatically
                tryLoadDefaultFile();
                
            } catch (error) {
                updateStatus(`‚ùå Failed to initialize ZenKit: ${error.message}`, 'error');
                console.error('ZenKit initialization error:', error);
            }
        }

        function updateStatus(message, type = 'loading') {
            console.log(message);
        }

        async function tryLoadDefaultFile() {
            try {
                updateStatus('üîç Looking for world file...', 'loading');
                
                const response = await fetch('/public/game-assets/WORLDS/NEWWORLD/NEWWORLD.ZEN');
                if (response.ok) {
                    const arrayBuffer = await response.arrayBuffer();
                    const uint8Array = new Uint8Array(arrayBuffer);
                    await processZenFile(uint8Array, arrayBuffer.byteLength);
                } else {
                    updateStatus('üìÇ World file not found.', 'loading');
                }
            } catch (error) {
                updateStatus('üìÇ World file not found.', 'loading');
            }
        }

        async function processZenFile(uint8Array, fileSize) {
            try {
                updateStatus(`üìñ Loading world file...`, 'loading');

                // Create world and load
                const world = ZenKit.createWorld();
                const success = world.loadFromArray(uint8Array);

                if (!success || !world.isLoaded) {
                    throw new Error(world.getLastError() || 'Unknown loading error');
                }

                const mesh = world.mesh;

                // Create 3D mesh
                createThreeJSMesh(mesh);

                updateStatus(`‚úÖ World file loaded successfully!`, 'success');

            } catch (error) {
                updateStatus(`‚ùå Failed to load world file: ${error.message}`, 'error');
                console.error('File processing error:', error);
            }
        }

        

        async function createThreeJSMesh(zenMesh) {
            // Remove existing mesh
            if (worldMesh) {
                scene.remove(worldMesh);
                worldMesh.geometry.dispose();
                if (Array.isArray(worldMesh.material)) {
                    worldMesh.material.forEach(m => m.dispose());
                } else {
                    worldMesh.material.dispose();
                }
            }
            
            try {
                console.log('üîß Using new getProcessedMeshData() with OpenGothic pipeline...');
                
                // Get processed mesh data (with material deduplication, composite vertices, sorting)
                const processed = zenMesh.getProcessedMeshData();
                
                // Convert Emscripten vectors to typed arrays
                const vertCount = processed.vertices.size();
                const idxCount = processed.indices.size();
                const matIdCount = processed.materialIds.size();
                const matCount = processed.materials.size();
                
                console.log(`Processed mesh: ${vertCount/8} vertices, ${idxCount/3} triangles, ${matCount} materials (deduplicated)`);
                
                // Build Three.js geometry from processed data
                // Vertices are [x,y,z, nx,ny,nz, u,v] √ó vertex_count
                const positions = new Float32Array(idxCount * 3); // Expand to non-indexed
                const normals = new Float32Array(idxCount * 3);
                const uvs = new Float32Array(idxCount * 2);
                
                for (let i = 0; i < idxCount; i++) {
                    const vertIdx = processed.indices.get(i);
                    const vertBase = vertIdx * 8;
                    
                    // Position
                    positions[i*3 + 0] = processed.vertices.get(vertBase + 0);
                    positions[i*3 + 1] = processed.vertices.get(vertBase + 1);
                    positions[i*3 + 2] = processed.vertices.get(vertBase + 2);
                    
                    // Normal
                    normals[i*3 + 0] = processed.vertices.get(vertBase + 3);
                    normals[i*3 + 1] = processed.vertices.get(vertBase + 4);
                    normals[i*3 + 2] = processed.vertices.get(vertBase + 5);
                    
                    // UV
                    uvs[i*2 + 0] = processed.vertices.get(vertBase + 6);
                    uvs[i*2 + 1] = processed.vertices.get(vertBase + 7);
                }
                
                const geometry = new THREE.BufferGeometry();
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                geometry.setAttribute('normal', new THREE.BufferAttribute(normals, 3));
                geometry.setAttribute('uv', new THREE.BufferAttribute(uvs, 2));
                
                // Build material groups based on processed material IDs
                // materialIds is per-triangle, so we need to find consecutive runs
                const triCount = matIdCount;
                geometry.clearGroups();
                
                let currentMatId = processed.materialIds.get(0);
                let groupStart = 0;
                
                for (let t = 1; t <= triCount; t++) {
                    const matId = (t < triCount) ? processed.materialIds.get(t) : -1; // Force flush at end
                    
                    if (t === triCount || matId !== currentMatId) {
                        // End of group
                        const vertexStart = groupStart * 3; // 3 vertices per triangle
                        const vertexCount = (t - groupStart) * 3;
                        geometry.addGroup(vertexStart, vertexCount, currentMatId);
                        
                        groupStart = t;
                        currentMatId = matId;
                    }
                }
                
                // Build materials array from deduplicated materials
                const materialArray = [];
                for (let mi = 0; mi < matCount; mi++) {
                    const mat = processed.materials.get(mi);
                    const fallback = new THREE.MeshBasicMaterial({ 
                        color: 0xFFFFFF,  // WHITE - don't tint the texture!
                        side: THREE.DoubleSide,
                        transparent: true,
                        alphaTest: 0.01
                    });
                    materialArray.push(fallback);
                    
                    // Load texture asynchronously
                    if (mat && mat.texture && mat.texture.length) {
                        const url = tgaNameToCompiledUrl(mat.texture);
                        loadCompiledTexAsDataTexture(url).then(tex => {
                            if (tex) {
                                materialArray[mi].map = tex;
                                materialArray[mi].needsUpdate = true;
                                renderer.render(scene, camera);
                            }
                        }).catch(() => {
                            console.warn(`Failed to load texture: ${mat.texture}`);
                        });
                    }
                }
                
                worldMesh = new THREE.Mesh(geometry, materialArray);
                
                // Compute bounding box
                geometry.computeBoundingBox();
                
                worldMesh.scale.x = -1; // Fix mirrored world
                
                scene.add(worldMesh);
                
                // Update stats
                stats.triangles = triCount;
                
                console.log('‚úÖ 3D mesh created successfully with processed data!');
                console.log(`   - ${matCount} deduplicated materials`);
                console.log(`   - ${vertCount/8} composite vertices`);
                console.log(`   - ${triCount} triangles (sorted by material)`);
                
                // Render once after creating the mesh
                renderer.render(scene, camera);
                
            } catch (error) {
                console.error('‚ùå Failed to create 3D mesh:', error);
                console.error('Error stack:', error.stack);
                updateStatus(`‚ùå Failed to create 3D mesh: ${error.message}`, 'error');
            }
        }

        
        function onWindowResize() {
            const canvas = document.getElementById('threejs-canvas');
            camera.aspect = canvas.clientWidth / canvas.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(canvas.clientWidth, canvas.clientHeight);
            renderer.render(scene, camera);
        }
        
        
        
        // Load .TEX from compiled path via WASM and build a DataTexture
        async function loadCompiledTexAsDataTexture(url) {
            const res = await fetch(url);
            if (!res.ok) return null;
            const buf = await res.arrayBuffer();
            const arr = new Uint8Array(buf);
            const zkTex = new ZenKit.Texture();
            const ok = zkTex.loadFromArray(arr);
            if (!ok || !ok.success) return null;
            const w = zkTex.width;
            const h = zkTex.height;
            const rgba = zkTex.asRgba8(0);
            if (!rgba) return null;
            const tex = new THREE.DataTexture(rgba, w, h, THREE.RGBAFormat);
            tex.needsUpdate = true;
            tex.flipY = false;  // OpenGothic doesn't flip Y
            tex.colorSpace = THREE.SRGBColorSpace;
            tex.anisotropy = renderer.capabilities.getMaxAnisotropy();
            // IMPORTANT: world UVs frequently exceed [0,1]; enable tiling
            tex.wrapS = THREE.RepeatWrapping;
            tex.wrapT = THREE.RepeatWrapping;
            tex.minFilter = THREE.LinearMipmapLinearFilter;
            tex.magFilter = THREE.LinearFilter;
            tex.generateMipmaps = true;
            return tex;
        }

        function tgaNameToCompiledUrl(name) {
            if (!name || typeof name !== 'string') return null;
            const base = name.replace(/\.[^.]*$/, '').toUpperCase();
            return `/public/game-assets/TEXTURES/_COMPILED/${base}-C.TEX`;
        }

        // Initialize on page load
        initZenKit();
    </script>
</body>
</html>